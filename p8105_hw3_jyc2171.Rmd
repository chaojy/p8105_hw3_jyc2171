---
title: "Homework 3"
name: "Jerry Chao, Uni: jyc2171"
date: "October 4, 2020"
output: github_document
---

This is my solution to Homework 3

Problem 0

I have created....

```{r setup}
library(tidyverse)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

Problem 1

```{r}
library(p8105.datasets)
data("instacart")
```

The instacart dataset contains `r nrow(instacart)` rows and `r ncol(instacart)` columns.  This is a big dataframe!  There appears to be 131,209 distinct user identification numbers.  There are 39,123  distinct product identification numbers corresponding to 39,123 product names, including "Im Pei-nut Butter" double chocolate cookie & peanut butter ice cream and #2 mechanical pencils as just two examples.  There are 134 aisles identification numbers corresponding to 134 aisles including air freshener candles, beer coolers, and baby food formula as some examples.  There are 21 department identification numbers corresponding to 21 departments, including alcohol, babies, and dry goods pasta as some examples.

Observations are the level of items in orders by user.  There are user / order varibles -- user ID, order ID, order day, and order hour.  There are also item variables -- name, aisle, department, and some numeric codes.

How many aisles, and which are most items from?
(this is a question about counting)

```{r}
instacart %>% 
  count(aisle) %>% 
  arrange(desc(n))
```
*desc(n) from most to least

Let's make a plot
(this is a filtering problem)

```{r}
instacart %>% 
  count(aisle) %>% 
  filter(n > 10000) %>% 
  ggplot(aes(x = aisle, y = n)) +
  geom_point()
```
*output is problematic

1) rotate axis labels.  google "rotate text"
```{r}
instacart %>% 
  count(aisle) %>% 
  filter(n > 10000) %>% 
  ggplot(aes(x = aisle, y = n)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


2) a sensible way to arrange is to put from least number of products on left to most on right (x axis).  Key concept is to realize that should recode categorical variable to factor.
```{r}
instacart %>% 
  count(aisle) %>% 
  filter(n > 10000) %>% 
  mutate(
    aisle = factor(aisle),
    aisle = fct_reorder(aisle, n)
  ) %>% 
  ggplot(aes(x = aisle, y = n)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

Let's make a table!!

```{r}
instacart %>% 
  filter(aisle %in% c("baking ingredients", "dog food care", "packaged vegetables fruits")) %>% 
  group_by(aisle) %>%
  count(product_name) %>% 
  mutate(
    rank = min_rank(desc(n))
  ) %>% 
  filter(rank < 4) %>% 
  arrange(aisle, rank) %>% 
  knitr::kable()
```

Pink lady apples and coffee ice cream

```{r}
instacart %>% 
  filter(product_name %in% c("Pink Lady Apples", "Coffee Ice Cream")) %>% 
##this product ordered 430 times
  group_by(product_name, order_dow) %>% 
  summarize(mean_hour = mean(order_hour_of_day)) %>% 
  pivot_wider(
    names_from = order_dow,
    values_from = mean_hour
  )
  

```


```{r}
instacart %>% 
  group_by(user_id) %>% 
  summarize(n_obs = n())

instacart %>% 
  group_by(product_id) %>% 
  summarize(n_obs = n())

instacart %>% 
  group_by(product_name) %>% 
  summarize(n_obs = n())

instacart %>% 
  group_by(aisle) %>% 
  summarize(n_obs = n())

instacart %>% 
  group_by(aisle, order_id) %>% 
  summarize(n_obs = n())

instacart %>% 
  group_by(department) %>% 
  summarize(n_obs = n())

instacart %>% 
  count(department, name = "n_obs")

instacart %>% 
  count(order_number, name = "n_obs")

instacart %>% 
  group_by(aisle, order_number) %>% 
  relocate(aisle, order_number)
  mutate(order_number_rank = min_rank(desc(order_number))) %>% 
  relocate(aisle, order_number_rank, order_number)

  summarize(n_obs = n())
```

min_rank function gives you the lowest rank (#1) for the variable you specify

```{r}
weather_df %>% 
  group_by(name, month) %>% 
  mutate(temp_rank = min_rank(desc(tmax))) %>% 
  filter(temp_rank == 1) %>% 
  view()
```
min_rank(desc(tmax)) allows you to calculate from the bottom up.